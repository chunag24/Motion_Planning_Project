
### Explain the starter code 

1. Explain the functionality of what's provided in motion_planning.py and planning_utils.py

   ###### Motion_Planning.py

   This is the main program that allows the drone to navigate the way through the grid. The difference between this file and the **backyard_flyer.py** is that the waypoints can be generated by using the plan_path function. The plan_path function uses the tools within **Planning_utilts** to complete the path planning and generate a list of waypoints which are then sent to the simulator for actual flying. 

   ###### Planning_utils.py

   The planning_utils.py provides all the tools that are required for the Motion_planning python file. This file includes functions such as create_grid, valid_actions, and a_star that could be called by the main python file. 

   The **create_grid function** takes the data from the CSV file, along with the drone_altitude, and a specified safety_distance to generate a grid representation of a 2D configuration space with obstacles in it.  This function also returns  the minimum north and east coordinates. They will be later used for offset purposes in the main python file.

   The **valid_actions** allows for the calculation of a list of valid actions given the grid and the current position. It calls for **Actions** class to access the attributes of that class. 

   Finally, the **a_star** function is the key part of the path planning process. It requires a grid, a **heuristic function**,  a start point, and a goal point. It invovles the use of several data structures to compute a list of waypoints which will be used for the main function. 

### Implementing your path planning algorithm

1. Set your global home position 

   Reading the first line of the csv file using 

   ```python
   filename = 'colliders.csv'
   import csv
   with open(filename, newline='') as f:
     reader = csv.reader(f)
     row1 = next(reader) 
   row1
   lat0 = row1[0].split()[1]
   lon0 = row1[1].split()[1]
   print(lat0, lon0)
   self.set_home_position(lon0, lat0, 0)
   ```

   

2. Set your current local position 

   ```python
   current_global_position = (self._latitude, self._longitude, self._altitude)
   #Converting from global location to current location
   current_local_position = global_to_local(current_global_position, self.global_home)
   
   ```

   

3. Set grid start position from local position 

   ```python
   grid_start = (int(self.local_position[0] - north_offset), int(self.local_position[1]-east_offset))
   
   ```

   

4. set grid goal position from geodetic cordination 

   ```python
   # TODO: convert start position to current position rather than map center
   # Set goal as some arbitrary position on the grid
   global_goal = np.array([-122.398570, 37.796150, 0.0])
   # TODO: adapt to set goal as latitude / longitude position and convert
   local_goal = global_to_local(global_goal, self.global_home)
   grid_goal = (int(local_goal[0] - north_offset), int(local_goal[1] east_offset))
   ```

5. Modify A* to include diagonal motion 

   ```python
   def heuristic(position, goal_position):
   
     return np.sqrt((position[0] - goal_position[0])**2 + (position[1] - goal_position[1])**2)
   ```

   

6. Cull waypoints 

   ```python
   def point(p):
       return np.array([p[0], p[1], 1.]).reshape(1, -1)
   
   def collinearity_check(p1, p2, p3, epsilon=1e-1):
       m = np.concatenate((p1, p2, p3), 0)
       det = np.linalg.det(m)
       return abs(det) < epsilon
       
   def prune_path(path):
       pruned_path = [p for p in path]
       i = 0
       while i < len(pruned_path) - 2:
           p1 = point(pruned_path[i])
           p2 = point(pruned_path[i+1])
           p3 = point(pruned_path[i+2])
           if collinearity_check(p1,p2,p3):
               pruned_path.remove(pruned_path[i+1])
           else:
               i+=1
       return pruned_path
   
   ```

   

### Execute the flight

The flight was executed successfully. However, the drone needs to be moved out of the spawn point to successfully execute the flight plan. 
